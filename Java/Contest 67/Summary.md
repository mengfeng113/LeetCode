# LeetCode Contest 67 Summary
## Porblem 1
第一题其实很简单，其实就是遍历一下[L,R]所有的数，每个数用位运算判断bit个数。但是我思考过多，在想有没有更加高效的算法。导致我有点犹豫，影响了速度。我所感觉的高效算法是，不需要遍历[L,R]，而是直接计算每一bit上出现1的次数。而这样的想法确实不知道怎么实现。因此我应当及时放弃自己没有任何思路的想法，找一个可行的解为先。
## Problem 2
第二题是Expedia online test的原题，我基本上做的还算顺利。但是就是不知有没有更高效的处理方式。因为我的算法里大量使用了String.lastIndexOf()，而这个API的效率是否是O(n)呢？如果是的话，那么我的算法就是O(n^2)。而关于String中API的效率，Uber面试的时候有个中国面试官说String.split()是完全遍历了一遍。
## Problem 3
第三题我没做出来，是因为我的算法非常naive。但其实只要多想一步就能想到。我的失误在于，没有仔细分析自己算法的 time/space complexity,并且下意识的不愿意使用O(n^2)级别的space.But memory is cheap! 我用类似邻接链表的方式记录了矩阵中0的位置，节省了一定的空间。但是时间复杂度是O(n^3).当时，我已经想到“需要知道的是：给定某个坐标，从这个位置向上下左右能够走的最远的距离”。但是没有仔细思考这个算法中的重复计算：当从[i,j]向左检测时，可以利用[i, j - 1]位置的信息，向右时可以使用[i, j + 1]位置的信息，上下两个方向同理。而总终需要的只是在各个方向上能够走最远距离的最小值，是一个minmax问题。可以从四个方向扫描矩阵，每个方向上都不会有重复计算，然后将结果暂存在一个矩阵中。这样的算法，time和space complexity都是O(n^2). 我当时只想着按照从上到下，从左到右的顺序遍历矩阵，思维非常僵化。
